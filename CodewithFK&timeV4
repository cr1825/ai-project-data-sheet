import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import r2_score, mean_squared_error
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import ipywidgets as widgets
from IPython.display import display, clear_output

# Load Dataset
url = "https://raw.githubusercontent.com/cr1825/ai-project-data-sheet/main/EdgeAI_Robot_Motion_Control_Dataset_expanded_5k.csv"
data = pd.read_csv(url)

print("‚úÖ Data Loaded Successfully")
print("Shape:", data.shape)

# Encode Categorical Variables
robot_encoder = LabelEncoder()
data['Robot_Model_Encoded'] = robot_encoder.fit_transform(data['Robot_Model'])

# Separate Data by Motion Type
pick_place_data = data[data['Motion_Type'].isin(['Pick', 'Place'])].copy()
weld_inspect_data = data[data['Motion_Type'].isin(['Weld', 'Inspect'])].copy()

# Train Position Model
X_position = pick_place_data[['Desired_Position', 'Desired_Velocity', 'Joint_ID', 'Robot_Model_Encoded']]
y_position = pick_place_data['Actual_Position']
X_pos_train, X_pos_test, y_pos_train, y_pos_test = train_test_split(X_position, y_position, test_size=0.2, random_state=42)

rf_position = RandomForestRegressor(n_estimators=300, max_depth=25, random_state=42, n_jobs=-1)
rf_position.fit(X_pos_train, y_pos_train)

# Evaluate Position Model
y_pos_pred = rf_position.predict(X_pos_test)
pos_r2 = r2_score(y_pos_test, y_pos_pred)
pos_rmse = np.sqrt(mean_squared_error(y_pos_test, y_pos_pred))

# Train Velocity Model
X_velocity = weld_inspect_data[['Desired_Position', 'Desired_Velocity', 'Joint_ID', 'Robot_Model_Encoded']]
y_velocity = weld_inspect_data['Actual_Velocity']
X_vel_train, X_vel_test, y_vel_train, y_vel_test = train_test_split(X_velocity, y_velocity, test_size=0.2, random_state=42)

rf_velocity = RandomForestRegressor(n_estimators=300, max_depth=25, random_state=42, n_jobs=-1)
rf_velocity.fit(X_vel_train, y_vel_train)

# Evaluate Velocity Model
y_vel_pred = rf_velocity.predict(X_vel_test)
vel_r2 = r2_score(y_vel_test, y_vel_pred)
vel_rmse = np.sqrt(mean_squared_error(y_vel_test, y_vel_pred))

print("\n" + "="*70)
print("üìä MODEL PERFORMANCE METRICS")
print("="*70)
print(f"\nüéØ POSITION MODEL (Pick & Place):")
print(f"   R¬≤ Score: {pos_r2:.4f}")
print(f"   RMSE: {pos_rmse:.4f}¬∞")

print(f"\nüöÄ VELOCITY MODEL (Weld & Inspect):")
print(f"   R¬≤ Score: {vel_r2:.4f}")
print(f"   RMSE: {vel_rmse:.4f}¬∞/s")
print("="*70)

print("\n‚úÖ Models trained successfully")

# Forward Kinematics
DH_PARAMS = {
    'link_lengths': [0.0, 0.425, 0.392, 0.0, 0.0, 0.0],
    'link_offsets': [0.163, 0.0, 0.0, 0.134, 0.100, 0.100]
}

def forward_kinematics(joint_angles):
    """Calculate end-effector position from joint angles (degrees)"""
    theta = [np.radians(angle) for angle in joint_angles]
    a = DH_PARAMS['link_lengths']
    d = DH_PARAMS['link_offsets']
    
    c1, s1 = np.cos(theta[0]), np.sin(theta[0])
    c2, s2 = np.cos(theta[1]), np.sin(theta[1])
    c23 = np.cos(theta[1] + theta[2])
    s23 = np.sin(theta[1] + theta[2])
    
    x = c1 * (a[1]*c2 + a[2]*c23 + d[3]*s23 + d[5]*np.sin(theta[1]+theta[2]+theta[3]))
    y = s1 * (a[1]*c2 + a[2]*c23 + d[3]*s23 + d[5]*np.sin(theta[1]+theta[2]+theta[3]))
    z = d[0] + a[1]*s2 + a[2]*s23 - d[3]*c23 - d[5]*np.cos(theta[1]+theta[2]+theta[3])
    
    return np.array([x, y, z])

def calculate_end_effector_coords(joint_positions):
    """Calculate end-effector from joint position dict"""
    angles = [joint_positions.get(i, 0.0) for i in range(1, 7)]
    return forward_kinematics(angles)

def calculate_movement_time(current_pos, target_pos, velocity, acceleration=10.0, deceleration=10.0):
    """Calculate time for joint movement"""
    distance = abs(target_pos - current_pos)
    t_accel = velocity / acceleration
    t_decel = velocity / deceleration
    d_accel = 0.5 * acceleration * t_accel**2
    d_decel = 0.5 * deceleration * t_decel**2
    
    if (d_accel + d_decel) >= distance:
        v_peak = np.sqrt(2 * distance * acceleration * deceleration / (acceleration + deceleration))
        t_accel = v_peak / acceleration
        t_decel = v_peak / deceleration
        t_constant = 0
    else:
        d_constant = distance - d_accel - d_decel
        t_constant = d_constant / velocity
    
    total_time = t_accel + t_constant + t_decel
    phases = {'acceleration': t_accel, 'constant_velocity': t_constant, 'deceleration': t_decel}
    return total_time, phases

def calculate_task_time(joint_movements, motion_type, overlap_factor=0.7):
    """Calculate total task time"""
    movement_times = []
    for movement in joint_movements:
        time, phases = calculate_movement_time(movement['current_pos'], movement['target_pos'], movement['velocity'])
        movement_times.append({
            'joint_id': movement['joint_id'],
            'time': time,
            'phases': phases,
            'distance': abs(movement['target_pos'] - movement['current_pos'])
        })
    
    max_time = max([m['time'] for m in movement_times]) if movement_times else 0
    total_sequential = sum([m['time'] for m in movement_times])
    actual_movement_time = max_time + (1 - overlap_factor) * (total_sequential - max_time)
    
    if motion_type == 'Pick & Place':
        total_overhead = 0.7
    else:
        total_overhead = 1.3
    
    total_time = actual_movement_time + total_overhead
    breakdown = {
        'movement_time': actual_movement_time,
        'overhead_time': total_overhead,
        'max_joint_time': max_time,
        'sequential_time': total_sequential,
        'overlap_factor': overlap_factor,
        'joint_details': movement_times
    }
    return total_time, breakdown

# Interactive Interface
available_robots = sorted(data['Robot_Model'].unique())
output = widgets.Output()
joint_movements_store = []

interface_title = widgets.HTML(value="<h2 style='color: #1976D2; text-align: center;'>ü§ñ Robot Motion Control with End-Effector Tracking</h2>")

robot_model = widgets.Dropdown(options=available_robots, value=available_robots[0], description='Robot Model:', style={'description_width': '150px'}, layout=widgets.Layout(width='400px'))
motion_type = widgets.Dropdown(options=['Pick & Place', 'Weld & Inspect'], value='Pick & Place', description='Motion Type:', style={'description_width': '150px'}, layout=widgets.Layout(width='400px'))
joint_id = widgets.Dropdown(options=list(range(1, 7)), value=1, description='Joint ID:', style={'description_width': '150px'}, layout=widgets.Layout(width='400px'))
current_position = widgets.FloatText(value=0.0, description='Current Position:', style={'description_width': '150px'}, layout=widgets.Layout(width='400px'))
desired_position = widgets.FloatText(value=45.0, description='Desired Position:', style={'description_width': '150px'}, layout=widgets.Layout(width='400px'))
desired_velocity = widgets.FloatText(value=2.0, description='Desired Velocity:', style={'description_width': '150px'}, layout=widgets.Layout(width='400px'))

add_joint_button = widgets.Button(description='‚ûï Add Joint', button_style='info', layout=widgets.Layout(width='180px', height='35px'))
clear_joints_button = widgets.Button(description='üóë Clear All', button_style='warning', layout=widgets.Layout(width='180px', height='35px'))
calculate_button = widgets.Button(description='‚è± Calculate Time', button_style='success', layout=widgets.Layout(width='180px', height='40px'))
visualize_button = widgets.Button(description='üìä Visualize Coords', button_style='primary', layout=widgets.Layout(width='180px', height='40px'))

joints_display = widgets.HTML(value="<div style='background-color: #F5F5F5; padding: 10px; border-radius: 5px;'><b>üìã Joint Queue:</b> (Empty)</div>")

info_box = widgets.HTML(value="<div style='background-color: #E3F2FD; padding: 10px; border-radius: 5px; margin: 10px 0;'><b>‚Ñπ Info:</b> Add joints (1-6), then calculate time and visualize end-effector coordinates.</div>")

def update_joints_display():
    if not joint_movements_store:
        joints_display.value = "<div style='background-color: #F5F5F5; padding: 10px; border-radius: 5px;'><b>üìã Joint Queue:</b> (Empty)</div>"
    else:
        html = "<div style='background-color: #E8F5E9; padding: 10px; border-radius: 5px;'>"
        html += f"<b>üìã Joints Added: {len(joint_movements_store)}</b><br><br>"
        for i, jm in enumerate(joint_movements_store, 1):
            if jm['motion_type'] == 'Pick & Place':
                html += f"<b>{i}. Joint {jm['joint_id']}</b>: {jm['current_pos']:.1f}¬∞ ‚Üí {jm['target_pos']:.1f}¬∞ (Vel: {jm['velocity']:.2f}¬∞/s)<br>"
            else:
                html += f"<b>{i}. Joint {jm['joint_id']}</b>: {jm['target_pos']:.1f}¬∞ (Vel: {jm['desired_vel']:.2f}‚Üí{jm['velocity']:.2f}¬∞/s)<br>"
        html += "</div>"
        joints_display.value = html

def update_prediction_type(change):
    global joint_movements_store
    joint_movements_store = []
    update_joints_display()

motion_type.observe(update_prediction_type, names='value')

def add_joint_movement(b):
    global joint_movements_store
    with output:
        clear_output(wait=True)
        
        if joint_movements_store:
            if joint_movements_store[0]['robot_model'] != robot_model.value or joint_movements_store[0]['motion_type'] != motion_type.value:
                print("‚ùå Error: Cannot mix different robot models or motion types!")
                return
        
        robot_model_encoded = robot_encoder.transform([robot_model.value])[0]
        joint_id_int = int(joint_id.value)
        
        print("\n" + "="*70)
        if motion_type.value == 'Pick & Place':
            input_data = pd.DataFrame({'Desired_Position': [desired_position.value], 'Desired_Velocity': [desired_velocity.value], 'Joint_ID': [joint_id_int], 'Robot_Model_Encoded': [robot_model_encoded]})
            predicted_pos = rf_position.predict(input_data)[0]
            predicted_vel = desired_velocity.value
            
            print(f"‚úÖ Joint {joint_id_int} added to PICK & PLACE queue")
            print("="*70)
            print(f"\nüì• INPUT:")
            print(f"   Desired Position: {desired_position.value:.2f}¬∞")
            print(f"   Desired Velocity: {desired_velocity.value:.2f}¬∞/s")
            print(f"\nüîÆ POSITION PREDICTION:")
            print(f"   Predicted Actual Position: {predicted_pos:.2f}¬∞")
            print(f"   Position Error: {abs(predicted_pos - desired_position.value):.4f}¬∞")
            print(f"\nüöÄ VELOCITY:")
            print(f"   Actual Velocity (used as-is): {predicted_vel:.2f}¬∞/s")
            
        else:  # Weld & Inspect
            input_data = pd.DataFrame({'Desired_Position': [desired_position.value], 'Desired_Velocity': [desired_velocity.value], 'Joint_ID': [joint_id_int], 'Robot_Model_Encoded': [robot_model_encoded]})
            predicted_vel = rf_velocity.predict(input_data)[0]
            predicted_pos = desired_position.value
            
            print(f"‚úÖ Joint {joint_id_int} added to WELD & INSPECT queue")
            print("="*70)
            print(f"\nüì• INPUT:")
            print(f"   Desired Position: {desired_position.value:.2f}¬∞")
            print(f"   Desired Velocity: {desired_velocity.value:.2f}¬∞/s")
            print(f"\nüéØ POSITION:")
            print(f"   Actual Position (used as-is): {predicted_pos:.2f}¬∞")
            print(f"\nüîÆ VELOCITY PREDICTION:")
            print(f"   Predicted Actual Velocity: {predicted_vel:.2f}¬∞/s")
            print(f"   Velocity Error: {abs(predicted_vel - desired_velocity.value):.4f}¬∞/s")
        
        movement = {
            'robot_model': robot_model.value,
            'motion_type': motion_type.value,
            'joint_id': joint_id_int,
            'current_pos': current_position.value,
            'desired_pos': desired_position.value,
            'desired_vel': desired_velocity.value,
            'target_pos': predicted_pos,
            'velocity': abs(predicted_vel) if predicted_vel != 0 else 1.0
        }
        joint_movements_store.append(movement)
        update_joints_display()
        
        print(f"\nüìã Total joints in queue: {len(joint_movements_store)}")
        print("="*70)

def clear_joints(b):
    global joint_movements_store
    joint_movements_store = []
    update_joints_display()
    with output:
        clear_output(wait=True)
        print("üóë All joint movements cleared!")

def visualize_coordinates(b):
    with output:
        clear_output(wait=True)
        
        if not joint_movements_store:
            print("‚ùå No joint movements! Add joints first.")
            return
        
        desired_joint_positions = {jm['joint_id']: jm['desired_pos'] for jm in joint_movements_store}
        actual_joint_positions = {jm['joint_id']: jm['target_pos'] for jm in joint_movements_store}
        
        desired_coords = calculate_end_effector_coords(desired_joint_positions)
        actual_coords = calculate_end_effector_coords(actual_joint_positions)
        position_error = actual_coords - desired_coords
        euclidean_distance = np.linalg.norm(position_error)
        
        print("\n" + "="*70)
        print("üìç END-EFFECTOR COORDINATE ANALYSIS")
        print("="*70)
        print(f"Motion Type: {joint_movements_store[0]['motion_type']}")
        print(f"\nüéØ DESIRED Position: X={desired_coords[0]:.4f}m, Y={desired_coords[1]:.4f}m, Z={desired_coords[2]:.4f}m")
        print(f"üîÆ ACTUAL Position:  X={actual_coords[0]:.4f}m, Y={actual_coords[1]:.4f}m, Z={actual_coords[2]:.4f}m")
        print(f"\nüìè ERROR: ŒîX={position_error[0]*1000:.2f}mm, ŒîY={position_error[1]*1000:.2f}mm, ŒîZ={position_error[2]*1000:.2f}mm")
        print(f"üìê Total Euclidean Error: {euclidean_distance*1000:.2f}mm")
        
        if euclidean_distance < 0.001:
            rating = "üü¢ EXCELLENT (< 1mm)"
        elif euclidean_distance < 0.005:
            rating = "üü° GOOD (< 5mm)"
        elif euclidean_distance < 0.010:
            rating = "üü† ACCEPTABLE (< 10mm)"
        else:
            rating = "üî¥ POOR (> 10mm)"
        print(f"\nüéØ ACCURACY: {rating}")
        
        # Show velocity information
        if joint_movements_store[0]['motion_type'] == 'Weld & Inspect':
            print("\n" + "-"*70)
            print("üöÄ VELOCITY PREDICTIONS:")
            print("-"*70)
            for i, jm in enumerate(joint_movements_store, 1):
                vel_error = abs(jm['velocity'] - jm['desired_vel'])
                print(f"Joint {jm['joint_id']}: Desired={jm['desired_vel']:.3f}¬∞/s ‚Üí Predicted={jm['velocity']:.3f}¬∞/s (Error: {vel_error:.4f}¬∞/s)")
        
        print("="*70)
        
        # Visualization
        fig = plt.figure(figsize=(16, 5))
        
        # 3D plot
        ax1 = fig.add_subplot(131, projection='3d')
        ax1.scatter(desired_coords[0], desired_coords[1], desired_coords[2], c='blue', s=200, marker='o', label='Desired', alpha=0.7)
        ax1.scatter(actual_coords[0], actual_coords[1], actual_coords[2], c='red', s=200, marker='^', label='Actual', alpha=0.7)
        ax1.plot([desired_coords[0], actual_coords[0]], [desired_coords[1], actual_coords[1]], [desired_coords[2], actual_coords[2]], 'g--', linewidth=2, label=f'Error: {euclidean_distance*1000:.2f}mm')
        ax1.set_xlabel('X (m)', fontweight='bold')
        ax1.set_ylabel('Y (m)', fontweight='bold')
        ax1.set_zlabel('Z (m)', fontweight='bold')
        ax1.set_title('3D End-Effector Position', fontsize=12, fontweight='bold')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        
        # XY projection
        ax2 = fig.add_subplot(132)
        ax2.scatter(desired_coords[0], desired_coords[1], c='blue', s=300, marker='o', label='Desired', alpha=0.7, edgecolors='darkblue', linewidths=2)
        ax2.scatter(actual_coords[0], actual_coords[1], c='red', s=300, marker='^', label='Actual', alpha=0.7, edgecolors='darkred', linewidths=2)
        ax2.plot([desired_coords[0], actual_coords[0]], [desired_coords[1], actual_coords[1]], 'g--', linewidth=2, label=f'XY Error: {np.sqrt(position_error[0]**2 + position_error[1]**2)*1000:.2f}mm')
        ax2.set_xlabel('X (m)', fontweight='bold')
        ax2.set_ylabel('Y (m)', fontweight='bold')
        ax2.set_title('XY Plane Projection', fontsize=12, fontweight='bold')
        ax2.legend()
        ax2.grid(True, alpha=0.3)
        ax2.axis('equal')
        
        # Error bars
        ax3 = fig.add_subplot(133)
        axes_labels = ['X', 'Y', 'Z']
        errors_mm = position_error * 1000
        colors = ['#1f77b4', '#ff7f0e', '#2ca02c']
        bars = ax3.bar(axes_labels, np.abs(errors_mm), color=colors, alpha=0.7, edgecolor='black', linewidth=1.5)
        
        for bar, val in zip(bars, errors_mm):
            height = bar.get_height()
            sign = '+' if val >= 0 else '-'
            ax3.text(bar.get_x() + bar.get_width()/2., height, f'{sign}{abs(val):.2f}mm', ha='center', va='bottom', fontsize=10, fontweight='bold')
        
        ax3.set_ylabel('Absolute Error (mm)', fontweight='bold')
        ax3.set_title('Position Error by Axis', fontsize=12, fontweight='bold')
        ax3.grid(axis='y', alpha=0.3)
        ax3.text(0.5, 0.95, f'Total: {euclidean_distance*1000:.2f}mm', transform=ax3.transAxes, ha='center', va='top', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5), fontsize=11, fontweight='bold')
        
        plt.tight_layout()
        plt.show()
        
        print("\n‚úÖ Visualization complete!")

def calculate_total_time(b):
    with output:
        clear_output(wait=True)
        
        if not joint_movements_store:
            print("‚ùå No joint movements! Add joints first.")
            return
        
        print("\n" + "="*70)
        print("‚è±  TASK TIME ESTIMATION REPORT")
        print("="*70)
        
        total_time, breakdown = calculate_task_time(joint_movements_store, joint_movements_store[0]['motion_type'], overlap_factor=0.7)
        
        print(f"\nüìã Robot: {joint_movements_store[0]['robot_model']} | Motion: {joint_movements_store[0]['motion_type']} | Joints: {len(joint_movements_store)}")
        print(f"\n‚è±  TIME: Movement={breakdown['movement_time']:.3f}s, Overhead={breakdown['overhead_time']:.3f}s")
        print(f"üéØ TOTAL TIME: {total_time:.3f} seconds ({total_time/60:.2f} minutes)")
        
        print(f"\nüìä JOINT DETAILS:")
        for i, jm in enumerate(breakdown['joint_details'], 1):
            if joint_movements_store[i-1]['motion_type'] == 'Pick & Place':
                print(f"{i}. Joint {joint_movements_store[i-1]['joint_id']}: {joint_movements_store[i-1]['current_pos']:.1f}¬∞ ‚Üí {joint_movements_store[i-1]['target_pos']:.1f}¬∞ | Vel: {joint_movements_store[i-1]['velocity']:.2f}¬∞/s | Time: {jm['time']:.3f}s")
            else:
                print(f"{i}. Joint {joint_movements_store[i-1]['joint_id']}: Position: {joint_movements_store[i-1]['target_pos']:.1f}¬∞ | Vel: {joint_movements_store[i-1]['desired_vel']:.2f}‚Üí{joint_movements_store[i-1]['velocity']:.2f}¬∞/s | Time: {jm['time']:.3f}s")
        
        # End-effector coordinates
        desired_joint_positions = {jm['joint_id']: jm['desired_pos'] for jm in joint_movements_store}
        actual_joint_positions = {jm['joint_id']: jm['target_pos'] for jm in joint_movements_store}
        
        desired_coords = calculate_end_effector_coords(desired_joint_positions)
        actual_coords = calculate_end_effector_coords(actual_joint_positions)
        position_error = actual_coords - desired_coords
        euclidean_distance = np.linalg.norm(position_error)
        
        print("\n" + "="*70)
        print("üìç END-EFFECTOR COORDINATES")
        print("="*70)
        print(f"üéØ Desired: X={desired_coords[0]:.4f}m, Y={desired_coords[1]:.4f}m, Z={desired_coords[2]:.4f}m")
        print(f"üîÆ Actual:  X={actual_coords[0]:.4f}m, Y={actual_coords[1]:.4f}m, Z={actual_coords[2]:.4f}m")
        print(f"üìè Error:   ŒîX={position_error[0]*1000:.2f}mm, ŒîY={position_error[1]*1000:.2f}mm, ŒîZ={position_error[2]*1000:.2f}mm")
        print(f"üìê Total Error: {euclidean_distance*1000:.2f}mm")
        print("="*70)

add_joint_button.on_click(add_joint_movement)
clear_joints_button.on_click(clear_joints)
calculate_button.on_click(calculate_total_time)
visualize_button.on_click(visualize_coordinates)

button_row = widgets.HBox([add_joint_button, clear_joints_button], layout=widgets.Layout(justify_content='space-between'))
action_row = widgets.HBox([calculate_button, visualize_button], layout=widgets.Layout(justify_content='space-between'))

input_section = widgets.VBox([
    interface_title, info_box, robot_model, motion_type, joint_id,
    current_position, desired_position, desired_velocity,
    button_row, joints_display, action_row
], layout=widgets.Layout(padding='20px', border='3px solid #1976D2', border_radius='10px', width='450px'))

main_interface = widgets.VBox([input_section, output], layout=widgets.Layout(padding='10px'))

display(main_interface)

print("\n‚ú® Interface ready! Add joints (1-6), calculate time, and visualize end-effector coordinates!")
