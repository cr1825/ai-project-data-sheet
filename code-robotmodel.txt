import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import r2_score, mean_squared_error
import matplotlib.pyplot as plt

# ===========================
# 1Ô∏è‚É£ Load Dataset
# ===========================
url = "https://raw.githubusercontent.com/cr1825/ai-project-data-sheet/main/EdgeAI_Robot_Motion_Control_Dataset.csv"
data = pd.read_csv(url)

print("‚úÖ Data Loaded Successfully")
print("Shape:", data.shape)
print("Columns:", data.columns.tolist())

# Check for required columns
required_cols = ["Joint_ID", "Desired_Position", "Desired_Velocity", 
                 "Actual_Position", "Actual_Velocity"]

# Check if Robot_Model column exists
has_robot_model = "Robot_Model" in data.columns

if has_robot_model:
    print("\nü§ñ Robot Model column detected!")
    robot_models = sorted(data["Robot_Model"].unique())
    print(f"Available Robot Models: {robot_models}")
else:
    print("\n‚ö†Ô∏è No Robot_Model column found. Creating default 'Universal' model.")
    data["Robot_Model"] = "Universal"
    robot_models = ["Universal"]

# ===========================
# 2Ô∏è‚É£ Analyze Dataset Structure
# ===========================
print("\nüìä Dataset Structure:")
for model in robot_models:
    model_data = data[data["Robot_Model"] == model]
    joints = sorted(model_data["Joint_ID"].unique())
    print(f"  ‚Ä¢ {model}: {len(joints)} joints ‚Üí {joints}")

# ===========================
# 3Ô∏è‚É£ Train Models for Each Robot & Joint Combination
# ===========================
results = []
models = {}

print("\nüöÄ Training Random Forest Models for Each Robot-Joint Combination...\n")

for robot_model in robot_models:
    robot_data = data[data["Robot_Model"] == robot_model]
    joint_ids = sorted(robot_data["Joint_ID"].unique())
    
    print(f"üîß Training models for {robot_model} ({len(joint_ids)} joints)...")
    
    for jid in joint_ids:
        joint_data = robot_data[robot_data["Joint_ID"] == jid]
        
        X = joint_data[["Desired_Position", "Desired_Velocity"]]
        y = joint_data[["Actual_Position", "Actual_Velocity"]]
        
        rf = RandomForestRegressor(
            n_estimators=300, max_depth=25, random_state=42, n_jobs=-1
        )
        rf.fit(X, y)
        
        # Store model with composite key
        model_key = (robot_model, jid)
        models[model_key] = rf
        
        # Training performance summary
        y_pred = rf.predict(X)
        r2_total = r2_score(y, y_pred)
        rmse_total = np.sqrt(mean_squared_error(y, y_pred))
        avg_path_dev = np.mean(np.abs(y["Actual_Position"] - y_pred[:, 0]))
        avg_vel_dev = np.mean(np.abs(y["Actual_Velocity"] - y_pred[:, 1]))
        
        results.append({
            "Robot_Model": robot_model,
            "Joint_ID": jid,
            "Training_Samples": len(joint_data),
            "R2_Total": r2_total,
            "RMSE_Total": rmse_total,
            "Avg_Path_Deviation": avg_path_dev,
            "Avg_Velocity_Deviation": avg_vel_dev
        })

summary_df = pd.DataFrame(results)
print("\nüèÅ Overall Model Summary per Robot-Joint:")
print(summary_df.to_string(index=False))

# ===========================
# 4Ô∏è‚É£ Prediction Function for Specific Robot Model
# ===========================
def predict_robot_joints(robot_model, joint_ids, desired_positions, desired_velocities):
    """
    Predict actual positions and velocities for a specific robot model.
    
    Args:
        robot_model: Name of the robot model
        joint_ids: List of joint IDs for this robot
        desired_positions: List of desired positions for each joint
        desired_velocities: List of desired velocities for each joint
    """
    if len(joint_ids) != len(desired_positions) or len(joint_ids) != len(desired_velocities):
        raise ValueError("Number of joints must match number of position/velocity inputs")
    
    preds = []
    pred_pos = []
    pred_vel = []
    
    for i, jid in enumerate(joint_ids):
        model_key = (robot_model, jid)
        model = models.get(model_key)
        
        if model is None:
            raise ValueError(f"Model for {robot_model} - Joint {jid} not found. Available: {list(models.keys())}")
        
        input_data = pd.DataFrame({
            "Desired_Position": [desired_positions[i]],
            "Desired_Velocity": [desired_velocities[i]]
        })
        predicted = model.predict(input_data)
        actual_pos, actual_vel = predicted[0]
        
        pos_dev = abs(desired_positions[i] - actual_pos)
        vel_dev = abs(desired_velocities[i] - actual_vel)
        
        preds.append({
            "Robot_Model": robot_model,
            "Joint_ID": f"J{jid}",
            "Desired_Position": desired_positions[i],
            "Pred_Actual_Position": actual_pos,
            "Position_Deviation": pos_dev,
            "Desired_Velocity": desired_velocities[i],
            "Pred_Actual_Velocity": actual_vel,
            "Velocity_Deviation": vel_dev
        })
        pred_pos.append(actual_pos)
        pred_vel.append(actual_vel)
    
    result_df = pd.DataFrame(preds)
    
    # ---- Compute overall R¬≤ & RMSE for user predictions ----
    r2_pos = r2_score(desired_positions, pred_pos)
    r2_vel = r2_score(desired_velocities, pred_vel)
    rmse_pos = np.sqrt(mean_squared_error(desired_positions, pred_pos))
    rmse_vel = np.sqrt(mean_squared_error(desired_velocities, pred_vel))
    
    print(f"\nü§ñ Predictions for Robot Model: {robot_model}")
    print("\nüîπ Predicted Deviation Summary for All Joints:")
    print(result_df.to_string(index=False))
    print("\nüìà Overall R¬≤ and RMSE for User Inputs:")
    print(f"Position ‚Üí R¬≤: {r2_pos:.4f}, RMSE: {rmse_pos:.4f}")
    print(f"Velocity ‚Üí R¬≤: {r2_vel:.4f}, RMSE: {rmse_vel:.4f}")
    
    # ---- Plot deviations ----
    plt.figure(figsize=(12, 5))
    
    x_pos = np.arange(len(result_df))
    width = 0.35
    
    plt.bar(x_pos - width/2, result_df["Position_Deviation"], width, 
            alpha=0.8, label="Position Deviation", color='steelblue')
    plt.bar(x_pos + width/2, result_df["Velocity_Deviation"], width,
            alpha=0.8, label="Velocity Deviation", color='coral')
    
    plt.title(f"Predicted Deviation per Joint - {robot_model}", fontsize=14, fontweight='bold')
    plt.xlabel("Joint ID", fontsize=12)
    plt.ylabel("Deviation", fontsize=12)
    plt.xticks(x_pos, result_df["Joint_ID"])
    plt.legend()
    plt.grid(axis='y', alpha=0.3)
    plt.tight_layout()
    plt.show()
    
    return result_df, r2_pos, r2_vel, rmse_pos, rmse_vel

# ===========================
# 5Ô∏è‚É£ Interactive User Input Section
# ===========================
print("\n" + "="*60)
print("üéØ ROBOT JOINT PREDICTION SYSTEM")
print("="*60)

# Select Robot Model
print(f"\nüìã Available Robot Models:")
for idx, model in enumerate(robot_models, 1):
    model_data = data[data["Robot_Model"] == model]
    joints = sorted(model_data["Joint_ID"].unique())
    print(f"  {idx}. {model} ({len(joints)} joints: {joints})")

if len(robot_models) > 1:
    model_choice = int(input(f"\nSelect Robot Model (1-{len(robot_models)}): ")) - 1
    selected_robot = robot_models[model_choice]
else:
    selected_robot = robot_models[0]
    print(f"\nUsing: {selected_robot}")

# Get joints for selected robot
robot_data = data[data["Robot_Model"] == selected_robot]
available_joints = sorted(robot_data["Joint_ID"].unique())

print(f"\n‚úÖ Selected Robot: {selected_robot}")
print(f"üìç Available Joints: {available_joints}")

# Option to predict for all joints or specific joints
print("\nOptions:")
print("  1. Predict for ALL joints")
print("  2. Predict for SPECIFIC joints")

option = input("\nChoose option (1 or 2): ").strip()

if option == "2":
    print(f"\nEnter joint IDs separated by commas (e.g., 1,3,5)")
    print(f"Available: {available_joints}")
    joint_input = input("Joint IDs: ").strip()
    selected_joints = [int(j.strip()) for j in joint_input.split(",")]
    
    # Validate joints
    invalid_joints = [j for j in selected_joints if j not in available_joints]
    if invalid_joints:
        raise ValueError(f"Invalid joints: {invalid_joints}. Available: {available_joints}")
else:
    selected_joints = available_joints

print(f"\nüß† Enter Desired Positions and Velocities for {len(selected_joints)} Joint(s):")

desired_positions = []
desired_velocities = []

for jid in selected_joints:
    print(f"\n--- Joint {jid} ---")
    dp = float(input(f"  Desired Position: "))
    dv = float(input(f"  Desired Velocity: "))
    desired_positions.append(dp)
    desired_velocities.append(dv)

# ===========================
# 6Ô∏è‚É£ Predict and Display Results
# ===========================
predicted_results, r2p, r2v, rmsep, rmsev = predict_robot_joints(
    selected_robot, selected_joints, desired_positions, desired_velocities
)

# Save results with robot model in filename
save_choice = input("\nüíæ Do you want to save the results to CSV? (y/n): ").strip().lower()
if save_choice == 'y':
    filename = f"Predicted_{selected_robot.replace(' ', '_')}_Joint_Deviations.csv"
    predicted_results.to_csv(filename, index=False)
    print(f"‚úÖ Results saved as '{filename}'")

print("\n" + "="*60)
print("‚ú® Prediction Complete!")
print("="*60)