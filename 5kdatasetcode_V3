import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import r2_score, mean_squared_error
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
import matplotlib.pyplot as plt
import ipywidgets as widgets
from IPython.display import display, clear_output

# ===========================
# 1Ô∏è‚É£ Load Dataset
# ===========================
url = "https://raw.githubusercontent.com/cr1825/ai-project-data-sheet/main/EdgeAI_Robot_Motion_Control_Dataset_expanded_5k.csv"
data = pd.read_csv(url)

print("‚úÖ Data Loaded Successfully")
print("Shape:", data.shape)
print("Columns:", data.columns.tolist())

# Check for required columns
required_cols = ["Motion_Type", "Robot_Model"]
missing_cols = [col for col in required_cols if col not in data.columns]
if missing_cols:
    print(f"\n‚ö† Missing columns: {missing_cols}")
    print("Available columns:", data.columns.tolist())
else:
    print(f"\nüìã Available Robot Models: {sorted(data['Robot_Model'].unique())}")
    print(f"\nüìã Available Motion Types: {sorted(data['Motion_Type'].unique())}")
    print(f"\nMotion Type Distribution:\n{data['Motion_Type'].value_counts()}")
    print(f"\nRobot Model Distribution:\n{data['Robot_Model'].value_counts()}")

# ===========================
# 2Ô∏è‚É£ Encode Categorical Variables
# ===========================
robot_encoder = LabelEncoder()
data['Robot_Model_Encoded'] = robot_encoder.fit_transform(data['Robot_Model'])

print(f"\nüî¢ Robot Model Encoding:")
for i, model in enumerate(robot_encoder.classes_):
    print(f"  {model} ‚Üí {i}")

# ===========================
# 3Ô∏è‚É£ Separate Data by Motion Type
# ===========================
pick_place_data = data[data['Motion_Type'].isin(['Pick', 'Place'])].copy()
weld_inspect_data = data[data['Motion_Type'].isin(['Weld', 'Inspect'])].copy()

print(f"\nüìä Data Distribution:")
print(f"  ‚Ä¢ Pick/Place samples: {len(pick_place_data)}")
print(f"  ‚Ä¢ Weld/Inspect samples: {len(weld_inspect_data)}")

# ===========================
# 4Ô∏è‚É£ MODEL 1: Position Accuracy for Pick & Place
# ===========================
print("\n" + "="*60)
print("üéØ MODEL 1: POSITION ACCURACY (Pick & Place Tasks)")
print("="*60)

X_position = pick_place_data[['Desired_Position', 'Desired_Velocity', 'Joint_ID', 'Robot_Model_Encoded']]
y_position = pick_place_data['Actual_Position']

X_pos_train, X_pos_test, y_pos_train, y_pos_test = train_test_split(
    X_position, y_position, test_size=0.2, random_state=42
)

print("\nüöÄ Training Position Prediction Model...")
rf_position = RandomForestRegressor(
    n_estimators=300, 
    max_depth=25, 
    random_state=42, 
    n_jobs=-1
)
rf_position.fit(X_pos_train, y_pos_train)

y_pos_train_pred = rf_position.predict(X_pos_train)
y_pos_test_pred = rf_position.predict(X_pos_test)

r2_pos_train = r2_score(y_pos_train, y_pos_train_pred)
r2_pos_test = r2_score(y_pos_test, y_pos_test_pred)
rmse_pos_train = np.sqrt(mean_squared_error(y_pos_train, y_pos_train_pred))
rmse_pos_test = np.sqrt(mean_squared_error(y_pos_test, y_pos_test_pred))
mae_pos_test = np.mean(np.abs(y_pos_test - y_pos_test_pred))

print("\nüìà Position Model Performance:")
print(f"  Training Set:")
print(f"    ‚Ä¢ R¬≤ Score: {r2_pos_train:.4f}")
print(f"    ‚Ä¢ RMSE: {rmse_pos_train:.4f}")
print(f"\n  Test Set:")
print(f"    ‚Ä¢ R¬≤ Score: {r2_pos_test:.4f}")
print(f"    ‚Ä¢ RMSE: {rmse_pos_test:.4f}")
print(f"    ‚Ä¢ MAE: {mae_pos_test:.4f}")

feature_importance_pos = pd.DataFrame({
    'Feature': ['Desired_Position', 'Desired_Velocity', 'Joint_ID', 'Robot_Model'],
    'Importance': rf_position.feature_importances_
}).sort_values('Importance', ascending=False)
print("\nüîç Feature Importance (Position Model):")
print(feature_importance_pos.to_string(index=False))

# ===========================
# 5Ô∏è‚É£ MODEL 2: Velocity Accuracy for Weld & Inspect
# ===========================
print("\n" + "="*60)
print("‚ö° MODEL 2: VELOCITY ACCURACY (Weld & Inspect Tasks)")
print("="*60)

X_velocity = weld_inspect_data[['Desired_Position', 'Desired_Velocity', 'Joint_ID', 'Robot_Model_Encoded']]
y_velocity = weld_inspect_data['Actual_Velocity']

X_vel_train, X_vel_test, y_vel_train, y_vel_test = train_test_split(
    X_velocity, y_velocity, test_size=0.2, random_state=42
)

print("\nüöÄ Training Velocity Prediction Model...")
rf_velocity = RandomForestRegressor(
    n_estimators=300, 
    max_depth=25, 
    random_state=42, 
    n_jobs=-1
)
rf_velocity.fit(X_vel_train, y_vel_train)

y_vel_train_pred = rf_velocity.predict(X_vel_train)
y_vel_test_pred = rf_velocity.predict(X_vel_test)

r2_vel_train = r2_score(y_vel_train, y_vel_train_pred)
r2_vel_test = r2_score(y_vel_test, y_vel_test_pred)
rmse_vel_train = np.sqrt(mean_squared_error(y_vel_train, y_vel_train_pred))
rmse_vel_test = np.sqrt(mean_squared_error(y_vel_test, y_vel_test_pred))
mae_vel_test = np.mean(np.abs(y_vel_test - y_vel_test_pred))

print("\nüìà Velocity Model Performance:")
print(f"  Training Set:")
print(f"    ‚Ä¢ R¬≤ Score: {r2_vel_train:.4f}")
print(f"    ‚Ä¢ RMSE: {rmse_vel_train:.4f}")
print(f"\n  Test Set:")
print(f"    ‚Ä¢ R¬≤ Score: {r2_vel_test:.4f}")
print(f"    ‚Ä¢ RMSE: {rmse_vel_test:.4f}")
print(f"    ‚Ä¢ MAE: {mae_vel_test:.4f}")

feature_importance_vel = pd.DataFrame({
    'Feature': ['Desired_Position', 'Desired_Velocity', 'Joint_ID', 'Robot_Model'],
    'Importance': rf_velocity.feature_importances_
}).sort_values('Importance', ascending=False)
print("\nüîç Feature Importance (Velocity Model):")
print(feature_importance_vel.to_string(index=False))

# ===========================
# 6Ô∏è‚É£ Comparative Summary
# ===========================
print("\n" + "="*60)
print("üìä COMPARATIVE MODEL SUMMARY")
print("="*60)

summary_table = pd.DataFrame({
    'Model': ['Position (Pick/Place)', 'Velocity (Weld/Inspect)'],
    'Train_R2': [r2_pos_train, r2_vel_train],
    'Test_R2': [r2_pos_test, r2_vel_test],
    'Train_RMSE': [rmse_pos_train, rmse_vel_train],
    'Test_RMSE': [rmse_pos_test, rmse_vel_test],
    'Test_MAE': [mae_pos_test, mae_vel_test],
    'Samples': [len(pick_place_data), len(weld_inspect_data)]
})

print("\n" + summary_table.to_string(index=False))

# ===========================
# 7Ô∏è‚É£ Visualization
# ===========================
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

axes[0, 0].scatter(y_pos_test, y_pos_test_pred, alpha=0.5, s=20)
axes[0, 0].plot([y_pos_test.min(), y_pos_test.max()], 
                [y_pos_test.min(), y_pos_test.max()], 'r--', lw=2)
axes[0, 0].set_xlabel('Actual Position', fontsize=11)
axes[0, 0].set_ylabel('Predicted Position', fontsize=11)
axes[0, 0].set_title(f'Position Model (Pick/Place)\nR¬≤={r2_pos_test:.4f}', 
                     fontsize=12, fontweight='bold')
axes[0, 0].grid(alpha=0.3)

residuals_pos = y_pos_test - y_pos_test_pred
axes[0, 1].scatter(y_pos_test_pred, residuals_pos, alpha=0.5, s=20)
axes[0, 1].axhline(y=0, color='r', linestyle='--', lw=2)
axes[0, 1].set_xlabel('Predicted Position', fontsize=11)
axes[0, 1].set_ylabel('Residuals', fontsize=11)
axes[0, 1].set_title(f'Position Model Residuals\nRMSE={rmse_pos_test:.4f}', 
                     fontsize=12, fontweight='bold')
axes[0, 1].grid(alpha=0.3)

axes[1, 0].scatter(y_vel_test, y_vel_test_pred, alpha=0.5, s=20, color='orange')
axes[1, 0].plot([y_vel_test.min(), y_vel_test.max()], 
                [y_vel_test.min(), y_vel_test.max()], 'r--', lw=2)
axes[1, 0].set_xlabel('Actual Velocity', fontsize=11)
axes[1, 0].set_ylabel('Predicted Velocity', fontsize=11)
axes[1, 0].set_title(f'Velocity Model (Weld/Inspect)\nR¬≤={r2_vel_test:.4f}', 
                     fontsize=12, fontweight='bold')
axes[1, 0].grid(alpha=0.3)

residuals_vel = y_vel_test - y_vel_test_pred
axes[1, 1].scatter(y_vel_test_pred, residuals_vel, alpha=0.5, s=20, color='orange')
axes[1, 1].axhline(y=0, color='r', linestyle='--', lw=2)
axes[1, 1].set_xlabel('Predicted Velocity', fontsize=11)
axes[1, 1].set_ylabel('Residuals', fontsize=11)
axes[1, 1].set_title(f'Velocity Model Residuals\nRMSE={rmse_vel_test:.4f}', 
                     fontsize=12, fontweight='bold')
axes[1, 1].grid(alpha=0.3)

plt.tight_layout()
plt.show()

# ===========================
# 8Ô∏è‚É£ Time Calculation Functions
# ===========================

def calculate_movement_time(current_pos, target_pos, velocity, acceleration=10.0, deceleration=10.0):
    """Calculate time for a joint to move from current to target position"""
    distance = abs(target_pos - current_pos)
    
    t_accel = velocity / acceleration
    t_decel = velocity / deceleration
    
    d_accel = 0.5 * acceleration * t_accel**2
    d_decel = 0.5 * deceleration * t_decel**2
    
    if (d_accel + d_decel) >= distance:
        v_peak = np.sqrt(2 * distance * acceleration * deceleration / (acceleration + deceleration))
        t_accel = v_peak / acceleration
        t_decel = v_peak / deceleration
        t_constant = 0
    else:
        d_constant = distance - d_accel - d_decel
        t_constant = d_constant / velocity
    
    total_time = t_accel + t_constant + t_decel
    
    phases = {
        'acceleration': t_accel,
        'constant_velocity': t_constant,
        'deceleration': t_decel
    }
    
    return total_time, phases

def calculate_task_time(joint_movements, motion_type, overlap_factor=0.7):
    """Calculate total task time considering all joint movements"""
    movement_times = []
    
    for movement in joint_movements:
        time, phases = calculate_movement_time(
            movement['current_pos'],
            movement['target_pos'],
            movement['velocity']
        )
        movement_times.append({
            'joint_id': movement['joint_id'],
            'time': time,
            'phases': phases,
            'distance': abs(movement['target_pos'] - movement['current_pos'])
        })
    
    max_time = max([m['time'] for m in movement_times]) if movement_times else 0
    total_sequential = sum([m['time'] for m in movement_times])
    actual_movement_time = max_time + (1 - overlap_factor) * (total_sequential - max_time)
    
    if motion_type == 'Pick & Place':
        gripper_time = 0.5
        settling_time = 0.2
        total_overhead = gripper_time + settling_time
    else:
        setup_time = 0.3
        process_time = 1.0
        total_overhead = setup_time + process_time
    
    total_time = actual_movement_time + total_overhead
    
    breakdown = {
        'movement_time': actual_movement_time,
        'overhead_time': total_overhead,
        'max_joint_time': max_time,
        'sequential_time': total_sequential,
        'overlap_factor': overlap_factor,
        'joint_details': movement_times
    }
    
    return total_time, breakdown

# ===========================
# 9Ô∏è‚É£ Enhanced Interactive Widget Interface
# ===========================
print("\n" + "="*60)
print("ü§ñ INTERACTIVE ROBOT MOTION PREDICTION INTERFACE")
print("="*60)

available_robots = sorted(data['Robot_Model'].unique())
available_joints = list(range(1, 7))
available_motion_types = sorted(data['Motion_Type'].unique())

output = widgets.Output()
joint_movements_store = []

interface_title = widgets.HTML(
    value="<h2 style='color: #1976D2; text-align: center;'>ü§ñ Robot Motion Control Predictor</h2>"
)

robot_model = widgets.Dropdown(
    options=available_robots,
    value=available_robots[0],
    description='Robot Model:',
    style={'description_width': '150px'},
    layout=widgets.Layout(width='400px')
)

motion_type = widgets.Dropdown(
    options=['Pick & Place', 'Weld & Inspect'],
    value='Pick & Place',
    description='Motion Type:',
    style={'description_width': '150px'},
    layout=widgets.Layout(width='400px')
)

prediction_type = widgets.Dropdown(
    options=['Position Prediction', 'Velocity Prediction'],
    value='Position Prediction',
    description='Prediction Type:',
    style={'description_width': '150px'},
    layout=widgets.Layout(width='400px'),
    disabled=True
)

joint_id = widgets.Dropdown(
    options=available_joints,
    value=1,
    description='Joint ID:',
    style={'description_width': '150px'},
    layout=widgets.Layout(width='400px')
)

current_position = widgets.FloatText(
    value=0.0,
    description='Current Position:',
    style={'description_width': '150px'},
    layout=widgets.Layout(width='400px')
)

desired_position = widgets.FloatText(
    value=45.0,
    description='Desired Position:',
    style={'description_width': '150px'},
    layout=widgets.Layout(width='400px')
)

desired_velocity = widgets.FloatText(
    value=2.0,
    description='Desired Velocity:',
    style={'description_width': '150px'},
    layout=widgets.Layout(width='400px')
)

add_joint_button = widgets.Button(
    description='‚ûï Add Joint Movement',
    button_style='info',
    icon='plus',
    layout=widgets.Layout(width='200px', height='35px')
)

clear_joints_button = widgets.Button(
    description='üóë Clear All Joints',
    button_style='warning',
    icon='trash',
    layout=widgets.Layout(width='200px', height='35px')
)

calculate_button = widgets.Button(
    description='‚è± Calculate Total Time',
    button_style='success',
    icon='clock-o',
    layout=widgets.Layout(width='200px', height='40px')
)

joints_display = widgets.HTML(
    value="<div style='background-color: #F5F5F5; padding: 10px; border-radius: 5px; min-height: 50px;'>"
          "<b>üìã Joint Movements Queue:</b> (Empty)</div>"
)

info_box = widgets.HTML(
    value="<div style='background-color: #E3F2FD; padding: 10px; border-radius: 5px; margin: 10px 0;'>"
          "<b>‚Ñπ Info:</b> Select Robot Model and Motion Type. Pick/Place predict <b>Position</b>, "
          "Weld/Inspect predict <b>Velocity</b>. Add joints (1-6) to calculate task time.</div>"
)

def update_prediction_type(change):
    global joint_movements_store
    joint_movements_store = []
    update_joints_display()
    
    if change['new'] == 'Pick & Place':
        # Update options first, then value
        prediction_type.options = ['Position Prediction', 'Velocity Prediction']
        prediction_type.value = 'Position Prediction'
        info_box.value = ("<div style='background-color: #E3F2FD; padding: 10px; border-radius: 5px; margin: 10px 0;'>"
                         "<b>üéØ Pick & Place Motion:</b> This motion focuses on accurate <b>positioning</b>. "
                         "Add joints (1-6) to calculate movement time.</div>")
    else:
        # Update options first, then value
        prediction_type.options = ['Position Prediction', 'Velocity Prediction']
        prediction_type.value = 'Velocity Prediction'
        info_box.value = ("<div style='background-color: #FFF3E0; padding: 10px; border-radius: 5px; margin: 10px 0;'>"
                         "<b>‚ö° Weld & Inspect Motion:</b> This motion requires precise <b>velocity control</b>. "
                         "Add joints (1-6) to calculate movement time.</div>")

motion_type.observe(update_prediction_type, names='value')

def update_joints_display():
    """Update the display of added joints"""
    if not joint_movements_store:
        joints_display.value = ("<div style='background-color: #F5F5F5; padding: 10px; border-radius: 5px; min-height: 50px;'>"
                               "<b>üìã Joint Movements Queue:</b> (Empty)</div>")
    else:
        joints_html = "<div style='background-color: #E8F5E9; padding: 10px; border-radius: 5px;'>"
        joints_html += f"<b>üìã Joint Movements Queue</b> (Robot: {joint_movements_store[0]['robot_model']}, Motion: {joint_movements_store[0]['motion_type']}):<br><br>"
        for i, jm in enumerate(joint_movements_store, 1):
            joints_html += f"<b>{i}. Joint {jm['joint_id']}</b>:<br>"
            joints_html += f"   <span style='color: #666;'>Input:</span> Desired Pos: {jm['desired_pos']:.2f}¬∞, Desired Vel: {jm['desired_vel']:.2f}¬∞/s<br>"
            joints_html += f"   <span style='color: #1976D2;'>Predicted:</span> Actual Pos: {jm['target_pos']:.2f}¬∞, Actual Vel: {jm['velocity']:.2f}¬∞/s<br>"
            joints_html += f"   Movement: {jm['current_pos']:.2f}¬∞ ‚Üí {jm['target_pos']:.2f}¬∞<br><br>"
        joints_html += "</div>"
        joints_display.value = joints_html

def add_joint_movement(b):
    """Add a joint movement to the queue"""
    global joint_movements_store
    
    with output:
        clear_output(wait=True)
        
        if joint_movements_store:
            if joint_movements_store[0]['robot_model'] != robot_model.value:
                print("‚ùå Error: Cannot mix different robot models in one task!")
                print(f"   Current queue uses: {joint_movements_store[0]['robot_model']}")
                print(f"   You selected: {robot_model.value}")
                return
            if joint_movements_store[0]['motion_type'] != motion_type.value:
                print("‚ùå Error: Cannot mix different motion types in one task!")
                print(f"   Current queue uses: {joint_movements_store[0]['motion_type']}")
                print(f"   You selected: {motion_type.value}")
                return
        
        robot_model_encoded = robot_encoder.transform([robot_model.value])[0]
        joint_id_int = int(joint_id.value)
        
        # Make prediction
        if motion_type.value == 'Pick & Place':
            input_data = pd.DataFrame({
                'Desired_Position': [desired_position.value],
                'Desired_Velocity': [desired_velocity.value],
                'Joint_ID': [joint_id_int],
                'Robot_Model_Encoded': [robot_model_encoded]
            })
            predicted_pos = rf_position.predict(input_data)[0]
            predicted_vel = desired_velocity.value
        else:
            input_data = pd.DataFrame({
                'Desired_Position': [desired_position.value],
                'Desired_Velocity': [desired_velocity.value],
                'Joint_ID': [joint_id_int],
                'Robot_Model_Encoded': [robot_model_encoded]
            })
            predicted_vel = rf_velocity.predict(input_data)[0]
            predicted_pos = desired_position.value
        
        movement = {
            'robot_model': robot_model.value,
            'motion_type': motion_type.value,
            'joint_id': joint_id_int,
            'current_pos': current_position.value,
            'desired_pos': desired_position.value,
            'desired_vel': desired_velocity.value,
            'target_pos': predicted_pos,
            'velocity': abs(predicted_vel) if predicted_vel != 0 else 1.0
        }
        joint_movements_store.append(movement)
        
        update_joints_display()
        
        print(f"‚úÖ Joint {joint_id_int} movement added successfully!")
        print(f"\nüì• INPUT VALUES:")
        print(f"   ‚Ä¢ Robot Model: {robot_model.value}")
        print(f"   ‚Ä¢ Motion Type: {motion_type.value}")
        print(f"   ‚Ä¢ Joint ID: {joint_id_int}")
        print(f"   ‚Ä¢ Current Position: {current_position.value:.2f}¬∞")
        print(f"   ‚Ä¢ Desired Position: {desired_position.value:.2f}¬∞")
        print(f"   ‚Ä¢ Desired Velocity: {desired_velocity.value:.2f}¬∞/s")
        
        print(f"\nüîÆ PREDICTED VALUES:")
        print(f"   ‚Ä¢ Predicted Actual Position: {predicted_pos:.2f}¬∞")
        print(f"   ‚Ä¢ Predicted Actual Velocity: {movement['velocity']:.2f}¬∞/s")
        
        position_error = abs(predicted_pos - desired_position.value)
        velocity_error = abs(movement['velocity'] - desired_velocity.value)
        
        print(f"\nüìä PREDICTION ACCURACY:")
        print(f"   ‚Ä¢ Position Error: {position_error:.4f}¬∞ ({(position_error/abs(desired_position.value)*100) if desired_position.value != 0 else 0:.2f}%)")
        print(f"   ‚Ä¢ Velocity Error: {velocity_error:.4f}¬∞/s ({(velocity_error/abs(desired_velocity.value)*100) if desired_velocity.value != 0 else 0:.2f}%)")
        
        print(f"\nüìã Total joints in queue: {len(joint_movements_store)}")

def clear_joints(b):
    """Clear all joint movements"""
    global joint_movements_store
    joint_movements_store = []
    update_joints_display()
    
    with output:
        clear_output(wait=True)
        print("üóë All joint movements cleared!")

def calculate_total_time(b):
    """Calculate total task time"""
    with output:
        clear_output(wait=True)
        
        if not joint_movements_store:
            print("‚ùå No joint movements added! Please add at least one joint movement.")
            return
        
        print("\n" + "="*70)
        print("‚è±  TASK TIME ESTIMATION REPORT")
        print("="*70)
        
        total_time, breakdown = calculate_task_time(
            joint_movements_store,
            joint_movements_store[0]['motion_type'],
            overlap_factor=0.7
        )
        
        print(f"\nüìã TASK DETAILS:")
        print(f"  ‚Ä¢ Robot Model: {joint_movements_store[0]['robot_model']}")
        print(f"  ‚Ä¢ Motion Type: {joint_movements_store[0]['motion_type']}")
        print(f"  ‚Ä¢ Number of Joints: {len(joint_movements_store)}")
        print(f"  ‚Ä¢ Parallel Execution: 70% (joints move simultaneously)")
        
        print(f"\n‚è±  TIME BREAKDOWN:")
        print(f"  ‚Ä¢ Pure Movement Time: {breakdown['movement_time']:.3f} seconds")
        print(f"  ‚Ä¢ Task Overhead Time: {breakdown['overhead_time']:.3f} seconds")
        print(f"  ‚Ä¢ Longest Joint Movement: {breakdown['max_joint_time']:.3f} seconds")
        print(f"  ‚Ä¢ Sequential Time (if no overlap): {breakdown['sequential_time']:.3f} seconds")
        
        print(f"\nüéØ TOTAL ESTIMATED TIME: {total_time:.3f} seconds ({total_time/60:.2f} minutes)")
        
        print(f"\nüìä INDIVIDUAL JOINT MOVEMENTS:")
        print("-" * 70)
        for i, jm in enumerate(breakdown['joint_details'], 1):
            print(f"\n{i}. Joint {joint_movements_store[i-1]['joint_id']}:")
            print(f"   Input: Desired Pos: {joint_movements_store[i-1]['desired_pos']:.2f}¬∞, Desired Vel: {joint_movements_store[i-1]['desired_vel']:.2f}¬∞/s")
            print(f"   Predicted: Actual Pos: {joint_movements_store[i-1]['target_pos']:.2f}¬∞, Actual Vel: {joint_movements_store[i-1]['velocity']:.2f}¬∞/s")
            print(f"   ‚Ä¢ Movement: {joint_movements_store[i-1]['current_pos']:.2f}¬∞ ‚Üí "
                  f"{joint_movements_store[i-1]['target_pos']:.2f}¬∞")
            print(f"   ‚Ä¢ Distance: {jm['distance']:.2f}¬∞")
            print(f"   ‚Ä¢ Time: {jm['time']:.3f}s "
                  f"(Accel: {jm['phases']['acceleration']:.3f}s, "
                  f"Constant: {jm['phases']['constant_velocity']:.3f}s, "
                  f"Decel: {jm['phases']['deceleration']:.3f}s)")
        
        print("\n" + "="*70)
        
        efficiency = (breakdown['max_joint_time'] / breakdown['sequential_time']) * 100
        print(f"\nüìà EFFICIENCY ANALYSIS:")
        print(f"  ‚Ä¢ Time saved by parallel execution: "
              f"{breakdown['sequential_time'] - breakdown['movement_time']:.3f} seconds")
        print(f"  ‚Ä¢ Efficiency gain: {100 - efficiency:.1f}%")
        
        if total_time < 2.0:
            rating = "‚ö° VERY FAST"
        elif total_time < 4.0:
            rating = "‚úÖ FAST"
        elif total_time < 6.0:
            rating = "‚úì MODERATE"
        elif total_time < 10.0:
            rating = "‚ö† SLOW"
        else:
            rating = "‚ùå VERY SLOW"
        
        print(f"\nüèÜ Performance Rating: {rating}")

add_joint_button.on_click(add_joint_movement)
clear_joints_button.on_click(clear_joints)
calculate_button.on_click(calculate_total_time)

button_row = widgets.HBox([add_joint_button, clear_joints_button], 
                          layout=widgets.Layout(justify_content='space-between'))

input_section = widgets.VBox([
    interface_title,
    info_box,
    robot_model,
    motion_type,
    prediction_type,
    joint_id,
    current_position,
    desired_position,
    desired_velocity,
    button_row,
    joints_display,
    calculate_button
], layout=widgets.Layout(
    padding='20px',
    border='3px solid #1976D2',
    border_radius='10px',
    width='450px'
))

main_interface = widgets.VBox([
    input_section,
    output
], layout=widgets.Layout(padding='10px'))

display(main_interface)

print("\n‚ú® Interactive interface ready!")
print("üí° Select Robot Model and Motion Type, then add joints (1-6) to calculate task time.")
print("üìä Input values and predicted actual values will be displayed when you add each joint.")
